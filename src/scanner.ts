import * as path from 'node:path';
import { writeFileSync, mkdirSync, readdirSync } from 'node:fs';
import { loadPathAliases, analyzeFiles } from './analyzer.js';
import { createGraph, addNode, getSummary, serializeGraph } from './graph.js';
import type { DependencyGraph, ScanOptions, GraphSummary } from './types.js';

const DEFAULT_EXCLUDE = [
  'node_modules',
  '.whobreaks',
  'dist',
  'build',
  '.next',
  '.nuxt',
  'coverage',
  '.git',
  '__pycache__',
  '.cache',
  '.turbo',
  'out',
  '.vercel',
];

const TS_EXTENSIONS = new Set(['.ts', '.tsx', '.js', '.jsx', '.mts', '.cts', '.mjs', '.cjs']);

function collectFiles(dir: string, excludeDirs: Set<string>): string[] {
  const results: string[] = [];

  let entries: import('node:fs').Dirent[];
  try {
    entries = readdirSync(dir, { withFileTypes: true });
  } catch {
    return results;
  }

  for (const entry of entries) {
    if (excludeDirs.has(entry.name)) continue;

    if (entry.isDirectory()) {
      const fullPath = path.join(dir, entry.name);
      const sub = collectFiles(fullPath, excludeDirs);
      for (let i = 0; i < sub.length; i++) results.push(sub[i]);
    } else if (entry.isFile()) {
      const ext = path.extname(entry.name);
      if (TS_EXTENSIONS.has(ext)) {
        results.push(path.join(dir, entry.name));
      }
    }
  }

  return results;
}

export interface ScanResult {
  graph: DependencyGraph;
  summary: GraphSummary;
  elapsedMs: number;
  fileCount: number;
}

export async function scanProject(options: ScanOptions): Promise<ScanResult> {
  const { projectRoot, exclude = [], maxFiles } = options;

  const excludeSet = new Set([...DEFAULT_EXCLUDE, ...exclude]);
  const startTime = Date.now();

  const allFiles = collectFiles(projectRoot, excludeSet);
  const files = maxFiles ? allFiles.slice(0, maxFiles) : allFiles;

  const aliases = loadPathAliases(projectRoot);
  const graph = createGraph(projectRoot);

  const nodes = await analyzeFiles(files, projectRoot, aliases);
  for (const node of nodes) {
    addNode(graph, node);
  }

  const summary = getSummary(graph);
  const elapsedMs = Date.now() - startTime;

  return {
    graph,
    summary,
    elapsedMs,
    fileCount: files.length,
  };
}

export function persistGraph(graph: DependencyGraph, projectRoot: string): void {
  const outputDir = path.join(projectRoot, '.whobreaks');
  mkdirSync(outputDir, { recursive: true });

  const graphData = serializeGraph(graph);
  writeFileSync(
    path.join(outputDir, 'graph.json'),
    JSON.stringify(graphData, null, 2),
    'utf-8'
  );

  const summary = getSummary(graph);
  writeFileSync(
    path.join(outputDir, 'summary.md'),
    buildSummaryMarkdown(summary, projectRoot),
    'utf-8'
  );
}

function buildSummaryMarkdown(summary: GraphSummary, projectRoot: string): string {
  const rel = (p: string) => path.relative(projectRoot, p);
  const lines: string[] = [];

  lines.push('# Architecture Map');
  lines.push('');
  lines.push(`> Generated by [whobreaks](https://github.com/f1729/whobreaks) on ${new Date().toISOString()}`);
  lines.push('');

  lines.push('## Summary');
  lines.push('');
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Files | ${summary.totalFiles} |`);
  lines.push(`| Dependency edges | ${summary.totalEdges} |`);
  lines.push(`| Avg dependents per file | ${summary.avgDependentsPerFile.toFixed(1)} |`);
  lines.push(`| Max dependency depth | ${summary.maxDepth} |`);
  lines.push(`| Circular dependencies | ${summary.circularDependencies.length} |`);
  lines.push(`| Orphan files | ${summary.orphanFiles.length} |`);
  lines.push(`| God modules (20+ dependents) | ${summary.godModules.length} |`);
  lines.push('');

  if (summary.circularDependencies.length > 0) {
    lines.push('## Circular Dependencies');
    lines.push('');
    for (const { cycle } of summary.circularDependencies) {
      lines.push(`- ${cycle.map(rel).join(' → ')}`);
    }
    lines.push('');
  }

  if (summary.godModules.length > 0) {
    lines.push('## God Modules');
    lines.push('');
    lines.push('Files imported by 20+ other files — high coupling risk.');
    lines.push('');
    for (const { path: p, dependentCount } of summary.godModules) {
      lines.push(`- \`${rel(p)}\` — ${dependentCount} dependents`);
    }
    lines.push('');
  }

  if (summary.highImpactFiles.length > 0) {
    lines.push('## High-Impact Files');
    lines.push('');
    lines.push('Changing these files has the widest transitive effect.');
    lines.push('');
    for (const { path: p, affectedCount } of summary.highImpactFiles.slice(0, 10)) {
      lines.push(`- \`${rel(p)}\` — ${affectedCount} files affected`);
    }
    lines.push('');
  }

  if (summary.orphanFiles.length > 0) {
    lines.push('## Orphan Files');
    lines.push('');
    lines.push('Not imported by anything — dead code candidates.');
    lines.push('');
    for (const p of summary.orphanFiles) {
      lines.push(`- \`${rel(p)}\``);
    }
    lines.push('');
  }

  return lines.join('\n');
}
